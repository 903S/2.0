import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import numpy as np
import networkx as nx
from matplotlib.patches import Patch
from typing import Optional, Dict, List, Any
import pandas as pd
import seaborn as sns
from pathlib import Path
try:
        import plotly.graph_objects as go
        from plotly.subplots import make_subplots
        PLOTLY_AVAILABLE = True
except ImportError:
        PLOTLY_AVAILABLE = False

# Import types that will be defined in other modules
from typing import TYPE_CHECKING
if TYPE_CHECKING:
        from env import PowerGridPartitionEnv

class VisualizationManager:
    """
    ÂèØËßÜÂåñÁÆ°ÁêÜÂô® - Áªü‰∏ÄÁÆ°ÁêÜÊâÄÊúâÂèØËßÜÂåñÂäüËÉΩ
    ÊîØÊåÅÈÖçÁΩÆÊñá‰ª∂È©±Âä®ÁöÑÂèØËßÜÂåñÂèÇÊï∞ËÆæÁΩÆ
    """
    
    def __init__(self, config: Dict[str, Any]):
        """
        ÂàùÂßãÂåñÂèØËßÜÂåñÁÆ°ÁêÜÂô®
        
        Args:
            config: ÂÆåÊï¥ÁöÑÈÖçÁΩÆÂ≠óÂÖ∏
        """
        self.config = config
        self.viz_config = config.get('visualization', {})
        self.enabled = self.viz_config.get('enabled', True)
        self.save_figures = self.viz_config.get('save_figures', True)
        self.figures_dir = Path(self.viz_config.get('figures_dir', 'figures'))
        
        # ÂàõÂª∫ÂõæÁâáÁõÆÂΩï
        if self.save_figures:
            self.figures_dir.mkdir(parents=True, exist_ok=True)
            
        # ËÆæÁΩÆmatplotlibÂèÇÊï∞
        self._setup_matplotlib()
        
    def _setup_matplotlib(self):
        """ËÆæÁΩÆmatplotlibÂÖ®Â±ÄÂèÇÊï∞"""
        figure_settings = self.viz_config.get('figure_settings', {})
        plt.rcParams['figure.dpi'] = figure_settings.get('dpi', 300)
        plt.rcParams['savefig.bbox'] = figure_settings.get('bbox_inches', 'tight')
        plt.rcParams['savefig.format'] = figure_settings.get('format', 'png')
        
    def get_color_palette(self, num_colors: int) -> List[str]:
        """
        Âä®ÊÄÅÁîüÊàêÈ¢úËâ≤ÊñπÊ°à
        
        Args:
            num_colors: ÈúÄË¶ÅÁöÑÈ¢úËâ≤Êï∞Èáè
            
        Returns:
            È¢úËâ≤ÂàóË°® (HEXÊ†ºÂºè)
        """
        colors_config = self.viz_config.get('colors', {})
        palette_type = colors_config.get('palette_type', 'husl')
        
        # ‰ΩøÁî®ÈÖçÁΩÆÁöÑÈ¢úËâ≤ÊñπÊ°à
        palette = sns.color_palette(palette_type, num_colors)
        return [f'#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}' for r, g, b in palette]
        
    def visualize_partition(self, env: 'PowerGridPartitionEnv', 
                          title: str = "Power Grid Partition",
                          save_path: Optional[str] = None) -> None:
        """
        ÂèØËßÜÂåñÁîµÁΩëÂàÜÂå∫ÁªìÊûú (Â∑≤‰øÆÂ§ç‰ª•ÂÖºÂÆπÊñ∞ÁâàÁéØÂ¢É)
        """
        if not self.enabled:
            return
            
        # ‰ªé env ÂØπË±°ÁöÑÊ≠£Á°Æ‰ΩçÁΩÆËé∑ÂèñÊï∞ÊçÆ
        try:
            # ‰ΩøÁî® state_manager Ëé∑ÂèñÂàÜÂå∫ÂíåËäÇÁÇπÊÄªÊï∞
            current_partition = env.state_manager.current_partition
            total_nodes = env.total_nodes
            num_partitions = env.num_partitions

            # ‰ΩøÁî® edge_info Ëé∑ÂèñËæπ‰ø°ÊÅØ
            edge_array = env.edge_info['edge_index'].cpu().numpy()
            
            # ‰ΩøÁî® evaluator Ëé∑ÂèñÁâ©ÁêÜÊï∞ÊçÆ
            node_pd = env.evaluator.load_active
            node_pg = env.evaluator.gen_active
            edge_admittance = env.evaluator.edge_admittances

        except AttributeError as e:
            print(f"‚ùå ÂèØËßÜÂåñÂ§±Ë¥•ÔºöÊó†Ê≥ï‰ªéenvÂØπË±°Ëé∑ÂèñÂøÖË¶ÅÁöÑÂ±ûÊÄß„ÄÇËØ∑Á°Æ‰øùenvÂØπË±°ÁªìÊûÑÊ≠£Á°Æ„ÄÇÈîôËØØ: {e}")
            return
            
        try:
            import gc
            
            # Ëé∑ÂèñÂàÜÂå∫ÂèØËßÜÂåñÈÖçÁΩÆ
            partition_config = self.viz_config.get('partition_plot', {})
            figsize = partition_config.get('figsize', [16, 10])
            show_metrics = partition_config.get('show_metrics', True)
            node_size_scale = partition_config.get('node_size_scale', 500)
            edge_alpha = partition_config.get('edge_alpha', 0.2)
            coupling_edge_width = partition_config.get('coupling_edge_width', 2)
            coupling_edge_alpha = partition_config.get('coupling_edge_alpha', 0.6)
            font_size = partition_config.get('font_size', 8)
            
            # ÂàõÂª∫ÂõæÂΩ¢ (ÁÆÄÂåñÁâàÊú¨Ôºå‰∏ìÊ≥®‰∫éÊ†∏ÂøÉÂèØËßÜÂåñ)
            fig, ax_main = plt.subplots(figsize=figsize)
            
            # ÂàõÂª∫NetworkXÂõæ
            G = nx.Graph()
            
            # Ê∑ªÂä†ËäÇÁÇπ
            for i in range(total_nodes):
                G.add_node(i)
            
            # Ê∑ªÂä†ËæπÔºàÂéªÈáçÔºâ
            edge_set = set()
            for i in range(edge_array.shape[1]):
                u, v = edge_array[0, i], edge_array[1, i]
                edge_set.add((min(u, v), max(u, v)))
            
            G.add_edges_from(list(edge_set))
            
            # ËÆ°ÁÆóÂ∏ÉÂ±Ä
            pos = nx.spring_layout(G, k=3, iterations=50, seed=42)
            
            # È¢úËâ≤ÊñπÊ°à
            unassigned_color = self.viz_config.get('colors', {}).get('unassigned_color', '#E0E0E0')
            colors = [unassigned_color] + self.get_color_palette(num_partitions)
            
            # ËäÇÁÇπÈ¢úËâ≤ÂíåÂ§ßÂ∞è
            node_colors = [colors[current_partition[i].item()] for i in range(total_nodes)]
            node_sizes = [300 + node_pd[i].item() * node_size_scale for i in range(total_nodes)]
            
            # ÁªòÂà∂Ëæπ
            nx.draw_networkx_edges(G, pos, alpha=edge_alpha, ax=ax_main)
            
            # È´ò‰∫ÆË∑®Âå∫ÂüüËæπ
            inter_edges = []
            for u, v in edge_set:
                if current_partition[u] > 0 and current_partition[v] > 0 and current_partition[u] != current_partition[v]:
                    inter_edges.append((u, v))
            
            nx.draw_networkx_edges(G, pos, edgelist=inter_edges, edge_color='red',
                                  width=coupling_edge_width, alpha=coupling_edge_alpha, ax=ax_main)
            
            # ÁªòÂà∂ËäÇÁÇπÂíåÊ†áÁ≠æ
            nx.draw_networkx_nodes(G, pos, node_color=node_colors, node_size=node_sizes,
                                  alpha=0.9, ax=ax_main)
            nx.draw_networkx_labels(G, pos, font_size=font_size, font_weight='bold', ax=ax_main)
            
            # Âõæ‰æã
            legend_elements = []
            for k in range(num_partitions + 1):
                count = (current_partition == k).sum().item()
                if k == 0:
                    label = f'Unassigned ({count} nodes)'
                else:
                    label = f'Region {k} ({count} nodes)'
                legend_elements.append(mpatches.Patch(color=colors[k], label=label))
            
            ax_main.legend(handles=legend_elements, loc='upper right', bbox_to_anchor=(1.15, 1))
            ax_main.set_title(title, fontsize=16, fontweight='bold')
            ax_main.axis('off')

            plt.tight_layout()
            
            # ‰øùÂ≠òÂõæÁâá
            if self.save_figures:
                if save_path is None:
                    save_path = self.figures_dir / 'partition_result.png'
                else:
                    save_path = self.figures_dir / save_path
                plt.savefig(save_path)
                print(f"üíæ ÂàÜÂå∫ÂõæÂ∑≤‰øùÂ≠òÂà∞: {save_path}")
            
            plt.show()
            
            # Ê∏ÖÁêÜÂÜÖÂ≠ò
            gc.collect()
            
        except Exception as e:
            print(f"‚ö†Ô∏è ÂèØËßÜÂåñÊâßË°åÂá∫Èîô: {e}")
            import traceback
            traceback.print_exc()
            try:
                plt.close('all')
                gc.collect()
            except:
                pass

    def plot_training_curves(self, history: Dict[str, List[float]], 
                           env_N: int = None, save_path: Optional[str] = None) -> None:
        """
        ÁªòÂà∂ËÆ≠ÁªÉÊõ≤Á∫ø
        """
        if not self.enabled:
            return
            
        # Ëé∑ÂèñËÆ≠ÁªÉÊõ≤Á∫øÈÖçÁΩÆ
        curves_config = self.viz_config.get('training_curves', {})
        figsize = curves_config.get('figsize', [12, 10])
        moving_average_window = curves_config.get('moving_average_window', 20)
        grid_alpha = curves_config.get('grid_alpha', 0.3)
        
        fig, axes = plt.subplots(2, 2, figsize=figsize)
        
        # 1. Â•ñÂä±Êõ≤Á∫ø
        ax = axes[0, 0]
        episodes = range(len(history['episode_rewards']))
        ax.plot(episodes, history['episode_rewards'], alpha=0.6, label='Episode Reward')
        
        # ÁßªÂä®Âπ≥Âùá
        if len(history['episode_rewards']) > 10:
            window = min(moving_average_window, len(history['episode_rewards']) // 5)
            moving_avg = pd.Series(history['episode_rewards']).rolling(window).mean()
            ax.plot(episodes, moving_avg, 'r-', linewidth=2, label=f'MA({window})')
        
        ax.set_xlabel('Episode')
        ax.set_ylabel('Total Reward')
        ax.set_title('Training Rewards')
        ax.legend()
        ax.grid(True, alpha=grid_alpha)
        
        # 2. Load CVÊõ≤Á∫ø
        ax = axes[0, 1]
        if 'load_cv' in history:
            ax.plot(episodes, history['load_cv'], 'g-', alpha=0.8)
            ax.set_ylim(0, max(history['load_cv']) * 1.1 if history['load_cv'] else 1)
        ax.set_xlabel('Episode')
        ax.set_ylabel('Load CV')
        ax.set_title('Load Balance (CV)')
        ax.grid(True, alpha=grid_alpha)
        
        # 3. ËÄ¶ÂêàÂ∫¶Êõ≤Á∫ø
        ax = axes[1, 0]
        if 'coupling_edges' in history:
            ax.plot(episodes, history['coupling_edges'], 'b-', alpha=0.8)
        ax.set_xlabel('Episode')
        ax.set_ylabel('Coupling Edges')
        ax.set_title('Inter-region Coupling')
        ax.grid(True, alpha=grid_alpha)
        
        # 4. EpisodeÈïøÂ∫¶
        ax = axes[1, 1]
        ax.plot(episodes, history['episode_lengths'], 'm-', alpha=0.8)
        ax.set_xlabel('Episode')
        ax.set_ylabel('Steps')
        ax.set_title('Episode Length')
        ax.grid(True, alpha=grid_alpha)
        
        # Ê∑ªÂä†ÂÆåÊàêÁ∫øÔºàÂ¶ÇÊûúÊèê‰æõ‰∫Üenv_NÔºâ
        if env_N is not None:
            ax.axhline(y=env_N, color='r', linestyle='--', alpha=0.5, label='Complete')
            ax.legend()
        
        fig.suptitle('Training Process Analysis', fontsize=16, fontweight='bold')
        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        
        # ‰øùÂ≠òÂõæÁâá
        if self.save_figures:
            if save_path is None:
                save_path = self.figures_dir / 'training_curves.png'
            else:
                save_path = self.figures_dir / save_path
            plt.savefig(save_path)
            print(f"üñºÔ∏è ËÆ≠ÁªÉÊõ≤Á∫øÂõæÂ∑≤‰øùÂ≠òÂà∞: {save_path}")
        plt.close()

    def create_interactive_visualization(self, env: 'PowerGridPartitionEnv', 
                                       comparison_df: pd.DataFrame) -> Optional[go.Figure]:
        """
        ÂàõÂª∫‰∫§‰∫íÂºèÂèØËßÜÂåñÔºà‰ΩøÁî®PlotlyÔºâ
        """
        interactive_config = self.viz_config.get('interactive', {})
        if not interactive_config.get('enabled', True) or not PLOTLY_AVAILABLE:
            print("‚ö†Ô∏è ‰∫§‰∫íÂºèÂèØËßÜÂåñÊú™ÂêØÁî®ÊàñPlotly‰∏çÂèØÁî®")
            return None
            
        import torch
        
        template = interactive_config.get('template', 'plotly_white')
        height = interactive_config.get('height', 800)
        
        # ÂàõÂª∫Â≠êÂõæ
        fig = make_subplots(
            rows=2, cols=3,
            subplot_titles=(
                'Network Topology', 'Method Comparison', 'Load Distribution',
                'Coupling Matrix', 'Metrics Radar', 'Region Statistics'
            ),
            specs=[
                [{'type': 'scatter'}, {'type': 'bar'}, {'type': 'bar'}],
                [{'type': 'heatmap'}, {'type': 'scatterpolar'}, {'type': 'table'}]
            ],
            column_widths=[0.4, 0.3, 0.3],
            row_heights=[0.6, 0.4]
        )
        
        # 1. ÁΩëÁªúÊãìÊâë
        G = nx.Graph()
        edge_array = env.edge_index.cpu().numpy()
        
        for i in range(env.N):
            G.add_node(i)
        
        edge_set = set()
        for i in range(edge_array.shape[1]):
            u, v = edge_array[0, i], edge_array[1, i]
            edge_set.add((min(u, v), max(u, v)))
        
        G.add_edges_from(list(edge_set))
        pos = nx.spring_layout(G, k=3, iterations=50, seed=42)
        
        # ÁªòÂà∂Ëæπ
        edge_x, edge_y = [], []
        for edge in G.edges():
            x0, y0 = pos[edge[0]]
            x1, y1 = pos[edge[1]]
            edge_x.extend([x0, x1, None])
            edge_y.extend([y0, y1, None])
        
        fig.add_trace(
            go.Scatter(x=edge_x, y=edge_y, mode='lines',
                      line=dict(width=0.5, color='#888'),
                      hoverinfo='none', showlegend=False),
            row=1, col=1
        )
        
        # ÁªòÂà∂ËäÇÁÇπ
        colors = ['#E0E0E0'] + self.get_color_palette(env.K)
        
        for k in range(env.K + 1):
            mask = (env.z == k)
            if mask.any():
                node_indices = torch.where(mask)[0].cpu().numpy()
                node_x = [pos[i][0] for i in node_indices]
                node_y = [pos[i][1] for i in node_indices]
                node_text = [f'Node {i}<br>Load: {env.Pd[i]:.3f}' for i in node_indices]
                
                fig.add_trace(
                    go.Scatter(
                        x=node_x, y=node_y,
                        mode='markers+text',
                        marker=dict(size=10, color=colors[k]),
                        text=[str(i) for i in node_indices],
                        textposition='top center',
                        hovertext=node_text,
                        hoverinfo='text',
                        name=f'Region {k}' if k > 0 else 'Unassigned'
                    ),
                    row=1, col=1
                )
        
        # 2. ÊñπÊ≥ïÊØîËæÉ
        fig.add_trace(
            go.Bar(
                x=comparison_df.index,
                y=comparison_df['overall_score'],
                marker_color=['green' if x == 'RL (PPO)' else 'lightblue' 
                             for x in comparison_df.index],
                text=[f'{v:.3f}' for v in comparison_df['overall_score']],
                textposition='outside'
            ),
            row=1, col=2
        )
        
        # 3. Ë¥üËç∑ÂàÜÂ∏É
        region_data = {'Region': [], 'Load': [], 'Generation': []}
        for k in range(1, env.K + 1):
            mask = (env.z == k)
            if mask.any():
                region_data['Region'].append(f'R{k}')
                region_data['Load'].append(env.Pd[mask].sum().item())
                region_data['Generation'].append(env.Pg[mask].sum().item())
        
        # Âä®ÊÄÅÁîüÊàêÈ¢úËâ≤
        bar_colors = self.get_color_palette(env.K)
        
        fig.add_trace(go.Bar(
            x=[f'R{i+1}' for i in range(env.K)],
            y=region_data['Load'],
            marker_color=bar_colors,
            name='Load'
        ), row=1, col=3)
        
        fig.add_trace(go.Bar(
            x=[f'R{i+1}' for i in range(env.K)],
            y=region_data['Generation'],
            marker_color=bar_colors,
            name='Generation'
        ), row=1, col=3)
        
        # 4. ËÄ¶ÂêàÁü©Èòµ
        coupling_matrix = np.zeros((env.K, env.K))
        for i in range(edge_array.shape[1]):
            u, v = edge_array[0, i], edge_array[1, i]
            if env.z[u] > 0 and env.z[v] > 0 and env.z[u] != env.z[v]:
                coupling_matrix[env.z[u]-1, env.z[v]-1] += env.admittance[i].item()
        
        fig.add_trace(
            go.Heatmap(
                z=coupling_matrix,
                x=[f'R{i+1}' for i in range(env.K)],
                y=[f'R{i+1}' for i in range(env.K)],
                colorscale='YlOrRd',
                text=np.round(coupling_matrix, 3),
                texttemplate='%{text}',
                textfont={'size': 10}
            ),
            row=2, col=1
        )
        
        # 5. ÊåáÊ†áÈõ∑ËææÂõæÔºàÂè™ÊòæÁ§∫RLÊñπÊ≥ïÔºâ
        metrics_to_plot = ['load_cv', 'connectivity', 'modularity']
        rl_values = [comparison_df.loc['RL (PPO)', m] for m in metrics_to_plot]
        
        # ÂΩí‰∏ÄÂåñÂà∞0-1ÔºàÁî®‰∫éÈõ∑ËææÂõæÔºâ
        norm_values = []
        for i, m in enumerate(metrics_to_plot):
            if m in ['load_cv']:  # Ë∂äÂ∞èË∂äÂ•Ω
                norm_values.append(1 - rl_values[i])
            else:  # Ë∂äÂ§ßË∂äÂ•Ω
                norm_values.append(rl_values[i])
        
        fig.add_trace(
            go.Scatterpolar(
                r=norm_values + [norm_values[0]],  # Èó≠Âêà
                theta=metrics_to_plot + [metrics_to_plot[0]],
                fill='toself',
                name='RL (PPO)'
            ),
            row=2, col=2
        )
        
        # 6. ÁªüËÆ°Ë°®Ê†º
        stats_data = [
            ['Total Nodes', str(env.N)],
            ['Regions', str(env.K)],
            ['Load CV', f'{env.current_metrics.load_cv:.4f}'],
            ['Total Coupling', f'{env.current_metrics.total_coupling:.4f}'],
            ['Connectivity', f'{env.current_metrics.connectivity:.2f}']
        ]
        
        fig.add_trace(
            go.Table(
                header=dict(values=['Metric', 'Value'],
                           fill_color='paleturquoise',
                           align='left'),
                cells=dict(values=list(zip(*stats_data)),
                          fill_color='lavender',
                          align='left')
            ),
            row=2, col=3
        )
        
        # Êõ¥Êñ∞Â∏ÉÂ±Ä
        fig.update_layout(
            title_text="Power Grid Partition Analysis Dashboard",
            title_font_size=20,
            showlegend=True,
            height=height,
            template=template
        )
        
        # Êõ¥Êñ∞Â≠êÂõæÊ†áÈ¢ò
        fig.update_xaxes(showgrid=False, row=1, col=1)
        fig.update_yaxes(showgrid=False, row=1, col=1)
        
        # ‰øùÂ≠òHTMLÊñá‰ª∂
        if interactive_config.get('save_html', True) and self.save_figures:
            html_path = self.figures_dir / 'interactive_partition_analysis.html'
            fig.write_html(str(html_path))
            print(f"üåê ‰∫§‰∫íÂºèÂõæË°®Â∑≤‰øùÂ≠òÂà∞: {html_path}")
        
        return fig

    def run_basic_visualization(self, env, history):
        """ËøêË°åÂü∫Á°ÄÂèØËßÜÂåñ"""
        if not self.enabled:
            return
            
        print("\nüìà ÁîüÊàêÂü∫Á°ÄÂèØËßÜÂåñÂõæË°®...")
        
        # ÂèØËßÜÂåñÊúÄÁªàÂàÜÂå∫
        self.visualize_partition(env, "Final Partition Result (RL)", "rl_partition_result.png")
        
        # ÁªòÂà∂ËÆ≠ÁªÉÊõ≤Á∫ø
        self.plot_training_curves(history, env_N=env.N, save_path="training_curves.png")

    def run_interactive_visualization(self, env, comparison_df):
        """ËøêË°å‰∫§‰∫íÂºèÂèØËßÜÂåñ"""
        interactive_config = self.viz_config.get('interactive', {})
        if not interactive_config.get('enabled', True):
            return
            
        if not PLOTLY_AVAILABLE:
            print("‚ö†Ô∏è PlotlyÊú™ÂÆâË£ÖÔºåË∑≥Ëøá‰∫§‰∫íÂºèÂèØËßÜÂåñ„ÄÇ")
            return
            
        print("üìä ÁîüÊàê‰∫§‰∫íÂºèÂØπÊØîÂõæË°®...")
        fig = self.create_interactive_visualization(env, comparison_df)
        
        if fig is not None:
            print(f"üåê ‰∫§‰∫íÂºèÂõæË°®ÂàõÂª∫ÊàêÂäü")


# ÂêëÂêéÂÖºÂÆπÁöÑÂáΩÊï∞Êé•Âè£
def get_color_palette(num_colors: int) -> List[str]:
    """ÂêëÂêéÂÖºÂÆπÁöÑÈ¢úËâ≤ÁîüÊàêÂáΩÊï∞"""
    palette = sns.color_palette("husl", num_colors)
    return [f'#{int(r*255):02x}{int(g*255):02x}{int(b*255):02x}' for r, g, b in palette]

def visualize_partition(env: 'PowerGridPartitionEnv', title: str = "Power Grid Partition",
                       save_path: Optional[str] = None, show_metrics: bool = True):
    """ÂêëÂêéÂÖºÂÆπÁöÑÂàÜÂå∫ÂèØËßÜÂåñÂáΩÊï∞ (Â∑≤‰øÆÂ§ç)"""
    # ‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆ
    default_config = {'visualization': {'enabled': True, 'save_figures': True}}
    viz_manager = VisualizationManager(default_config)
    viz_manager.visualize_partition(env, title, save_path)

def plot_training_curves(history: Dict[str, List[float]], env_N: int = None, save_path: Optional[str] = None):
    """ÂêëÂêéÂÖºÂÆπÁöÑËÆ≠ÁªÉÊõ≤Á∫øÂáΩÊï∞"""
    # ‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆ
    default_config = {'visualization': {'enabled': True, 'save_figures': True}}
    viz_manager = VisualizationManager(default_config)
    viz_manager.plot_training_curves(history, env_N, save_path)

def run_basic_visualization(env, history):
    """ÂêëÂêéÂÖºÂÆπÁöÑÂü∫Á°ÄÂèØËßÜÂåñÂáΩÊï∞"""
    default_config = {'visualization': {'enabled': True, 'save_figures': True}}
    viz_manager = VisualizationManager(default_config)
    viz_manager.run_basic_visualization(env, history)

def create_interactive_visualization(env: 'PowerGridPartitionEnv', 
                                   comparison_df: pd.DataFrame) -> go.Figure:
    """ÂêëÂêéÂÖºÂÆπÁöÑ‰∫§‰∫íÂºèÂèØËßÜÂåñÂáΩÊï∞"""
    default_config = {'visualization': {'enabled': True, 'save_figures': True}}
    viz_manager = VisualizationManager(default_config)
    return viz_manager.create_interactive_visualization(env, comparison_df)

def run_interactive_visualization(env, comparison_df):
    """ÂêëÂêéÂÖºÂÆπÁöÑ‰∫§‰∫íÂºèÂèØËßÜÂåñÂáΩÊï∞"""
    default_config = {'visualization': {'enabled': True, 'save_figures': True}}
    viz_manager = VisualizationManager(default_config)
    viz_manager.run_interactive_visualization(env, comparison_df)

